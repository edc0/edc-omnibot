\section{Revisão Bibliográfica}
\label{sec:revbib}

\subsection{Fundamentação Teórica}

% modelagem
Para que se possa compreender o comportamento de um robô e desenvolver aplicações, é necessário obter o modelo de tal robô. Para robôs móveis, em contraste com braços robóticos, por exemplo, há um nível de complexidade adicional na estimação da posição do robô, visto que a plataforma móvel não possui nenhuma extremidade fixa em um ponto conhecido. No caso do robô omnidirecional com 3 rodas, se deseja obter um \textbf{modelo cinemático} que relacione as velocidades de cada roda à posição do robô no ambiente. Para robôs móveis em geral, primeiro se deve analisar as restrições de movimento adicionadas ao sistema por cada roda. Ao se utilisar rodas omnidirecionais, tais restrições não existem, simplificando a obtenção da cinemática direta do TOMR. Tal análise é demonstrada por diversos autores, como \cite{siegwart2011introduction}, por exemplo, e será utilizada nas próximas seções. Ainda de acordo com os autores, conforme a velocidade de operação aumenta, se torna importante realizar a análise dos efeitos dinâmicos do sistema -- massa e força -- durante a implantação. A \textbf{modelagem dinâmica} do robô em questão ainda é discutida, variando conforme a aplicação desejada. VERIFICAR ESSA ÚLTIMA INFO.

%controle
\cite{siegwart2011introduction}: seguimento de trajetória: malha aberta (3.6.1); Feedback (3.6.2) do livro: It is very similar to the controllers presented in [39, 100]. Others can be found in [8, 52, 53, 137]. Controle com uma matriz de ganhos K para o espaço de estados. Estável e tal. Comentam sobre camadas: planejamento -> decisão -> controlador em tempo real -> hardware.

\cite{lynch2017modern}: Controle realimentado em robôs omnidirecionais é relativamente simples, visto que sempre há um conjunto de velocidades para as rodas que ocasiona numa certa velocidade (translacional e rotacional) para o robô, $\dot{q}$. Linearmente controlável se \textbf{kalman rank condition satisfied -> VERIFICAR ISSO AQUI (13.3.2)}. Definição de controlabilidade logo depois, e tenho q entender melhor. Posso dizer q o TOMR é controlável?

\cite{siciliano2016springer}: Capítulo 8, torque computado. Vou precisar?

\cite{spong2005robot}: Capítulo 8.2, PD CONTROL REVISITED
% centralizado vs descentralizado: 22 do indiveri
% intro do oubatti é muito boa
% samani tem uma bela revisão de controle

%odometria
\cite{lynch2017modern}: Odometry is the process of estimating the chassis configuration q from wheel motions, essentially integrating the wheel velocities. Since wheel rotation sensing is available on all mobile robots, odometry is cheap and convenient. Estimation errors tend to accumulate over time, though, due to unexpected slipping and skidding of the wheels and due to numerical integration error. Therefore, it is common to supplement odometry with other position sensors, like GPS, visual recognition of landmarks, ultrasonic beacons, laser or ultrasonic range sensing, etc. Those sensing modalities have their own measurement uncertainty, but errors do not accumulate over time. As a result, odometry generally gives superior results on short time scales, but the odometric estimates should either (a) be periodically corrected by other sensing modalities or, preferably, (b) integrated with other sensing modalities in an estimation framework based on a Kalman filter, particle filter, or similar.

\cite{siegwart2011introduction}: manipuladores robóticos podem ter sua posição medida diretamente, pois possum uma parte fixa ao ambiente, enquanto robôs móveis devem ter sua posição inerentemente estimada, gerando erros, etc. Após obter os dados do ambiente, se deve fazer a \textbf{localização} do robô no ambiente. Sucesso em navegação necessita de \textbf{percepção} (a leitura dos sensores em si), \textbf{localização}, \textbf{cognição} (decidir agir de acordo com o esperado) e \textbf{controle da movimentação}, quando se aplica a ação desejada. Destas áreas, localização é uma das que mais vem sendo estudada. Diversas limitações surgem: ruídos dos sensores, ruídos dos atuadores, aliasing (?)... Odometria utilizando encoders, e dead-reckoning (definir) utilizando sensores de direção adicionais, necessitam de integrações, que acumulam erros. Assim o ideal é atualizar a posição de acordo com outros sensores de tempos em tempos, em relação a marcadores absolutos de posição no ambiente (landmarks). Mais detalhes nas fontes de erro na pg 185. Começa considerando ambientes cheios de objetos, para detectar a distância das paredes, e fala de lugares abertos como se fosse um problema. Talvez n seja bem localização o q eu tô fazendo. Markov: probabilidade sobre a posição. Kalman: fusão dos dados dos sensores (e é mais eficiente que Markov Chains). Filtro de Kalman é um método matemático que produz uma estimativa ótima do estado de um sistema baseado no conhecimento deste sistema e dos sensores utilizados, incluindo erros de medição e incertezas dos modelos

\cite{siciliano2016springer}: Capítulo 35, Sensor Data Fusion

%implantação
\cite{siegwart2011introduction}: Para implementar, além das propriedades cinemáticas apresentadas, restrições dinâmicas devem ser inseridas nos modelos quando se aumentam as velocidades envolvidas. Para realizar a motorização, se deve entender do controle utilizado (pg 81).

\cite{siciliano2016springer}: Capítulo 12, Arquitetura de sistemas robóticos.

\cite{craig2017introduction}: pg 350, chapter 12 -> linguagens de programação para robótica

O \textbf{Raspberry Pi} é um \emph{single board computer}, que utiliza a arquitetura \acrshort{arm} em seu processador, ideal para dispositivos alimentados por baterias por consumir pouca energia e gerar pouco calor. O processador possui quatro núcleos, e um \emph{clock} de 1,2 GHz -- poder computacional equivalente há um computador de mesa comum. O \acrshort{rpi} utiliza um sistema operacional GNU/Linux, e \emph{software} deve ser desenvolvido para ser executado nesta plataforma. Há ainda 40 pinos de \acrshort{gpio} que podem ser utilizados para conectar sensores, atuadores e diversos componentes, e suporte nativo a \acrshort{i2c} (\cite{upton2014raspberry}).

% Software, implementação
% - tempo de ciclo
% - real-time
% - protocolos de comunicação

Para a comunicação dos periféricos com este computador, é necessário utilizar algum protocolo de comunicação. O protocolo \textbf{\acrlong{i2c}}, é geralmente utilizado em robôs, com um grande suporte tanto pela \acrshort{rpi} (\cite{upton2014raspberry}) quanto pelos componentes em geral utilizados (\cite{MPU6050} e a bússola e o arduino se eu usar). Com este protocolo, descrito em \cite{semiconductors2000i2c}, dados podem ser transmitidos a 100 Kbps -- ou 400 Kbps quando utilizado o \emph{fast mode}. São utilizados duas linhas bidirecionais no barramento: SDA para os dados e SCL para os sinais de \emph{clock}. O número de dispositivos conectados ao barramento só depende do limite de capacitância descrito na especificação. Resistores de \emph{pull-up} são necessários para manter a linha em estado lógico alto quando não utilizada, porém estes resistores estão presentes internamente no \emph{Raspberry Pi}, por exemplo.

ARDUINO? TEMPO REAL? PATH PLANNING e TRAJETÓRIA? INCLUIR A FUNDAMENTAÇÃO DE CADA SENSOR?

\subsection{Estado da Arte}

%% RODAS
A grande maioria dos robôs construídos com \textbf{\emph{omniwheels}} utiliza 3 rodas em uma configuração triangular simétrica -- como apresentado na Figura \ref{fig:tomr_ritter} --, a exemplo de \cite{ritter2016modelagem}, \cite{samani2007comprehensive}, \cite{williams2002dynamic} e \cite{indiveri2009swedish}, entre outros. Alguns autores, como \cite{krinkin2015design} e \cite{rojas2006holonomic} utilizam 4 rodas, sendo que este último desenvolveu algoritmos para que o robô continuasse operando mesmo que um dos motores deixe de funcionar. Em diversos trabalhos existe uma preocupação em relação a possíveis derrapagens das rodas ao aumentar a velocidade de operação. \cite{williams2002dynamic} apresentam um estudo sobre os coeficientes de atrito de rodas omnidirecionais em diversas superfícies e um modelo dinâmico que leva tal efeito em consideração.

%% MODELAGEM e CONTROLE
Há muitas técnicas de \textbf{controle} desenvolvidas para estes sistemas. Assim, é possível que cada autor utilize a que mais convenha às suas necessidades específicas. \cite{ritter2016modelagem} utiliza um controlador PID para cada roda, com parâmetros escolhidos empiricamente. Por sua vez, o robô torna-se difícil de controlar com velocidades acima de 1 m/s, segundo resultados de simulações. \cite{samani2007comprehensive} utilizam 3 PID, para controlar posição e orientação do robô. Em contraste, \cite{rojas2006holonomic} e \cite{indiveri2009swedish} também utilizam PID, porém para o controle de individual de cada motor, utilizando apenas o modelo cinemático do sistema. \cite{indiveri2009swedish} também sugere estratégias para evitar saturação dos atuadores.

Tanto \cite{treesatayapun2011discrete} quanto \cite{oubbati2005velocity} utilizam redes neurais para ajustar parâmetros dos controladores, sendo que no primeiro se tem uma estrutura de controle baseada em redes neurais enquanto que no segundo se utilizam as redes para calcular os parâmetros de 5 controladores PID, melhorando o desempenho mesmo levando em consideração de não-linearidades nos modelos dinâmicos utilizados. \cite{oubbati2005velocity} ainda mencionam que os resultados obtidos não foram os melhores possíveis, devido à dificuldade de se coletar dados de treinamento para as redes.

%% ODOMETRIA:
A maioria das implementações de robôs móveis hoje em dia combinam diversas técnicas de \textbf{localização e odometria} para implantar a realimentação necessária aos sistemas de controle. \cite{ginzburg2013indoor} propõem um sistema de localização para robô omnidirecional baseado em odometria (localização relativa) e triangulação ativa de sensores no ambiente (localização absoluta), com fusão de dados para obter o resultado final. \cite{rojas2006holonomic} utilizam a leitura dos \emph{encoders} das rodas e uma câmera externa, enquanto que \cite{garcia2015gyro} utilizam apenas um giroscópio e um sensor de distância. \cite{rohrig2010laser}, por outro lado, utilizam medições de distância utilizando sensores laser em AGV.

\cite{lowcostIMU} mostram que é possível executar um algoritmo de determinação de atitude a partir de uma IMU utilizando TRIAD, filtros de Kalman, covariância de Allen e a plataforma Arduino UNO, com razoável precisão. \cite{park1996dead} também analisam fusão de dados utilizando um filtro de Kalman indireto para realizar \emph{dead-reckoning} a partir da leitura de \emph{encoders} e um giroscópio. Métodos de localização também são desenvolvidos em outras áreas, como relata \cite{jimenez2009comparison}, que implementam três métodos de localização baseados em INS para trajetórias de pedestres, concluindo que os resultados podem ser melhorados quando há mais qualidade na detecção da orientação. \cite{steinhoff2010pocket} obtiveram resultados similares na mesma área.

%% SOFTWARE
Dos trabalhos mencionados, poucos entram em detalhes quanto ao \emph{hardware} utilizado. \cite{oubbati2005velocity} utilizam um computador embarcado de 2,6 GHz, uma grande evolução em relação a \cite{feng1989servo}, que utilizavam um computador Motorola 68000 com aproximadamente um milésimo da capacidade computacional daquele. \cite{takemura2007development} e \cite{loh2003mechatronics} utilizam computadores externos, envolvendo atrasos na comunicação entre tais computadores e o robô. \cite{lowcostIMU} apresentam um sistema que implementa um filtro de Kalman em um microprocessador Arduino UNO, uma alternativa de baixo custo. Diversos trabalhos mais recentes, como \cite{krinkin2015design}, utilizam especificamente o computador embarcado \textbf{Raspberry Pi} para o processamento e um \textbf{Arduino} para a interface com sensores e atuadores -- solução esta também adotada neste trabalho.
