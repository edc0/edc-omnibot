\section{Revisão Bibliográfica}
\label{sec:revbib}

\subsection{Fundamentação Teórica}

% modelagem
Para que se possa compreender o comportamento de um robô e desenvolver aplicações, é necessário obter o modelo de tal robô. Para robôs móveis, em contraste com braços robóticos, por exemplo, há um nível de complexidade adicional na estimação da posição do robô, visto que a plataforma móvel não possui nenhuma extremidade fixa em um ponto conhecido. No caso do robô omnidirecional com 3 rodas, se deseja obter um \textbf{modelo cinemático} que relacione as velocidades de cada roda à posição do robô no ambiente. Para robôs móveis em geral, primeiro se deve analisar as restrições de movimento adicionadas ao sistema por cada roda. Ao se utilisar rodas omnidirecionais, tais restrições não existem, simplificando a obtenção da cinemática direta do TOMR. Tal análise é demonstrada por diversos autores, como \cite{siegwart2011introduction}, por exemplo, e será utilizada nas próximas seções. Ainda de acordo com os autores, conforme a velocidade de operação aumenta, se torna importante realizar a análise dos efeitos dinâmicos do sistema -- massa e força -- durante a implantação. A \textbf{modelagem dinâmica} do robô em questão ainda é discutida, variando conforme a aplicação desejada, sendo uma das opções apresentada por \cite{kim2014minenergy}.

% planejamento de trajetória:
Também são apresentados por \cite{lynch2017modern} diversos métodos de \textbf{planejamento de trajetória} para robôs, ou seja, a maneira como o robô (ou um efetuador) se movimenta de um determinado ponto até outro. Há diversos métodos de se implantar trajetórias, com diversos níveis de complexidade computacional. Implementações mais simples podem ser uma linha reta de um ponto a outro, com atuação repentina, causando picos de aceleração, ou mais refinadas, realizado interpolações polinomiais de quinta ordem para garantir velocidades e acelerações nulas nos pontos de origem e destino. Também é importante analisar o perfil de velocidade executado pelo robô, para garantir a operação mais eficiente possível para as características dinâmicas de cada aplicação.

% controle
Segundo \cite{lynch2017modern}, aplicar controle com realimentação em robôs omnidirecionais é relativamente simples, visto que esse tipo de plataforma robótica apresenta controlabilidade -- ou seja, sempre há um conjunto de velocidades \textbf{$\dot\phi$} para as rodas que ocasiona numa certa velocidade \textbf{$v$} (translacional e rotacional) para o robô. \cite{siegwart2011introduction} sugerem a utilização de um controlador com realimentação de estados. Neste paradigma, o algoritmo de geração de trajetória divide o caminho a ser percorrido em diversos pontos, e o controlador implementado garante que o robô percorra tal trajeto, como se os dois sistemas -- planejamento de trajetória e controle --, estivessem operando em camadas hierárquicas.

A maioria dos autores se concentra em controladores que levam em consideração apenas a modelagem cinemática do sistema. No entanto, nos casos em que o modelo do robô exija considerações dinâmicas e não-lineares, controladores mais complexos são utilizados. Dentre outros, \cite{siciliano2016springer} descrevem o método de controle por torque computado, bastante popular, no qual o modelo dinâmico inverso é utilizado para linearizar a malha de controle. Ainda, conforme \cite{indiveri2009swedish}, o controle por torque computador configura um sistema de controle centralizado, enquanto a utilização de um PID para cada roda seria um exemplo de controle descentralizado.

%odometria
A localização do robô no ambiente é essencial para o bom funcionamento de um robô móvel. Conforme \cite{lynch2017modern}, se realiza \textbf{odometria} -- a medição da distância percorrida -- atrávés da integração das velocidades das rodas. Como o sensoriamento das rodas é muito comum, através de \textit{encoders} de quadratura, por exemplo, tornando a odometria algo barato e conveniente. No entanto, devido às sucessivas integrações realizadas, erros de estimação tendem a se acumular ao longo do tempo de operação, devido a deslizamentos das rodas e erros numéricos, principalmente. Sensores relativos como acelerômetros e giroscópios também tendem a acumular o mesmo tipo de erro. Assim, conforme \cite{siegwart2011introduction}, se recomenda utilizar métodos de localização absolutos de tempo em tempo, como magnetômetros, GPS e marcadores fixos no ambiente, ou, conforme complementado por \cite{lynch2017modern}, se pode realizar uma integração das leituras de diversos sensores. Esse método é chamado de \textbf{fusão de dados}.

%Caso necessário, capítulo 35 de \cite{siegwart2011introduction}: Sensor Data Fusion.

%implantação

Poucos trabalhos entram em detalhes a respeito da implantação dos sistemas desenvolvidos. De acordo com \cite{craig2017introduction}, tal fato se deve às constantes mudanças e atualizações tecnológicas em \textit{hardware} e linguagens de programação. Os autores tratam, então, de apresentar os fundamentos básicos da implementação, cabendo a cada pesquisador definir suas soluções a partir do que está disponível. Para \cite{siciliano2016springer}, a escolha da arquitetura utilizada é muito subjetiva, sendo comum tratar o robô como um conjunto de subsistemas. Tal abordagem busca melhorar a modularidade do sistema, facilitar a reutilização de módulos em outros projetos e facilitar testes, validações e manutenção. Arquiteturas mais voltadas à robótica tendem a incluir capacidades de processamento em  tempo real, controle de atuadores e sensores, e por vezes operam em diferentes camadas de prioridade, com escalas de tempo diferentes para diferentes tarefas.

\cite{craig2017introduction} ainda apresentam diversos paradigmas para as linguagens de programação utilizadas em robótica, sendo que uma das grandes tendências hoje é a utilização de linguagens gerais já existentes, com a adição de bibliotecas voltadas para o desenvolvimento de aplicações robóticas (ou o desenvolvimento das próprias bibliotecas). A escolha da linguagem a ser utilizada, conforme \cite{siciliano2016springer}, deve ser realizada com cuidado, com o objetivo de manter o desenvolvimento do sistema mais fácil, seguro e flexível. Assim, essa escolha pode ser baseada nas experiências anteriores do desenvolvedor, no tipo de robô e nas tarefas que se deseja executar, sem haver um consenso da comunidade acadêmica sobre qual a melhor abordagem.

\subsection{Estado da Arte}

%% RODAS

A grande maioria dos robôs construídos com \textbf{\emph{omniwheels}} utiliza 3 rodas em uma configuração triangular simétrica -- como apresentado na Figura \ref{fig:tomr_ritter} --, a exemplo de \cite{ritter2016modelagem}, \cite{samani2007comprehensive}, \cite{williams2002dynamic} e \cite{indiveri2009swedish}, entre outros. Alguns autores, como \cite{krinkin2015design} e \cite{rojas2006holonomic} utilizam 4 rodas, sendo que este último desenvolveu algoritmos para que o robô continuasse operando mesmo que um dos motores deixe de funcionar. Em diversos trabalhos existe uma preocupação em relação a possíveis derrapagens das rodas ao aumentar a velocidade de operação. \cite{williams2002dynamic} apresentam um estudo sobre os coeficientes de atrito de rodas omnidirecionais em diversas superfícies e um modelo dinâmico que leva tal efeito em consideração. \cite{samani2007comprehensive} utilizam 3 rodas motrizes e outras 3 rodas livres ligadas a \textit{encoders}, para que deslizamentos devido a torque excessivo não afetem a odometria.

\cite{jung2001fault} construíram um robô omnidirecional e um sistema de transmissão mecânica que permite holonomicidade utilizando rodas convencionais. Sugerem ainda modos de operação para o robô caso algum dos motores parem de funcionar, passando a se comportar de maneira similar a um robô diferencial. Nestes casos de falha, no entanto, se perde a capacidade omnidirecional.

%% MODELAGEM e CONTROLE
Há muitas técnicas de \textbf{controle} desenvolvidas para estes sistemas. Assim, é possível que cada autor utilize a que mais convenha às suas necessidades específicas. \cite{ritter2016modelagem} utiliza um controlador PID para cada roda, com parâmetros escolhidos empiricamente. Por sua vez, o robô torna-se difícil de controlar com velocidades acima de 1 m/s, segundo resultados de simulações. \cite{samani2007comprehensive} utilizam 3 PID, para controlar posição e orientação do robô, e relatam em detalhes o desenvolvimento de tais controladores. Em contraste, \cite{rojas2006holonomic} e \cite{indiveri2009swedish} também utilizam PID, porém para o controle de individual de cada motor, utilizando apenas o modelo cinemático do sistema. \cite{indiveri2009swedish} também sugere estratégias para evitar saturação dos atuadores.

Tanto \cite{treesatayapun2011discrete} quanto \cite{oubbati2005velocity} utilizam redes neurais para ajustar parâmetros dos controladores, sendo que no primeiro se tem uma estrutura de controle baseada em redes neurais enquanto que no segundo se utilizam as redes para calcular os parâmetros de 5 controladores PID, melhorando o desempenho mesmo levando em consideração de não-linearidades nos modelos dinâmicos utilizados. \cite{oubbati2005velocity} ainda mencionam que os resultados obtidos não foram os melhores possíveis, devido à dificuldade de se coletar dados de treinamento para as redes.

%% ODOMETRIA:
A maioria das implementações de robôs móveis hoje em dia combinam diversas técnicas de \textbf{localização e odometria} para implantar a realimentação necessária aos sistemas de controle. \cite{ginzburg2013indoor} propõem um sistema de localização para robô omnidirecional baseado em odometria (localização relativa) e triangulação ativa de sensores no ambiente (localização absoluta), com fusão de dados para obter o resultado final. \cite{rojas2006holonomic} utilizam a leitura dos \emph{encoders} das rodas e uma câmera externa, enquanto que \cite{garcia2015gyro} utilizam apenas um giroscópio e um sensor de distância. \cite{rohrig2010laser}, por outro lado, utilizam medições de distância utilizando sensores laser em AGV.

\cite{lowcostIMU} mostram que é possível executar um algoritmo de determinação de atitude a partir de uma IMU utilizando TRIAD, filtros de Kalman, covariância de Allen e a plataforma Arduino UNO, com razoável precisão. \cite{park1996dead} também analisam fusão de dados utilizando um filtro de Kalman indireto para realizar \emph{dead-reckoning} a partir da leitura de \emph{encoders} e um giroscópio. Métodos de localização também são desenvolvidos em outras áreas, como relata \cite{jimenez2009comparison}, que implementam três métodos de localização baseados em INS para trajetórias de pedestres, concluindo que os resultados podem ser melhorados quando há mais qualidade na detecção da orientação. \cite{steinhoff2010pocket} obtiveram resultados similares na mesma área.

%% SOFTWARE
Dos trabalhos mencionados, poucos entram em detalhes quanto ao \emph{hardware} utilizado. \cite{oubbati2005velocity} utilizam um computador embarcado de 2,6 GHz, uma grande evolução em relação a \cite{feng1989servo}, que utilizavam um computador Motorola 68000 com aproximadamente um milésimo da capacidade computacional daquele. \cite{takemura2007development} e \cite{loh2003mechatronics} utilizam computadores externos, envolvendo atrasos na comunicação entre tais computadores e o robô. \cite{lowcostIMU} apresentam um sistema que implementa um filtro de Kalman em um microprocessador Arduino UNO, uma alternativa de baixo custo. Diversos trabalhos mais recentes, como \cite{krinkin2015design}, utilizam especificamente o computador embarcado \textbf{Raspberry Pi} para o processamento e um \textbf{Arduino} para a interface com sensores e atuadores -- solução esta também adotada neste trabalho.

%% TESTES
Para a avaliação dos resultados da plataforma construída, \cite{loh2003mechatronics} implementaram 4 tipos de trajetória: translação retilínea , translação curvilínea -- ambas sem alteração na orientação --, rotação pura e um caminho combinado de rotação em torno do seu centro e translação retilínia em relação às referências globais. Duas canetas foram montadas no robô, uma no centro e outra na periferia, para avaliar o resultado das movimentações executadas.
